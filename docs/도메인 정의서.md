---
title: 마켓플레이스 정산 시스템 - 도메인 정의서
created: 2025-12-01
updated: 2025-12-01
tags: [project, settlement, ddd, domain]
category: Projects
status: draft
---

# 마켓플레이스 정산 시스템 - 도메인 정의서

## 1. 도메인 개요

### 시스템 목적

마켓플레이스에서 발생한 주문/결제/환불 내역을 기반으로, 판매자에게 지급할 금액을 주기적으로 산출하는 시스템이다.

### 핵심 문제

```
"어제 판매자 A가 얼마를 벌었고, 우리는 얼마를 지급해야 하는가?"
```

이 단순한 질문에 답하려면 다음을 해결해야 한다:

| 문제 | 복잡성 |
|------|--------|
| 정산 기준 시점 | 주문 시점? 결제 확정 시점? 배송 완료 시점? |
| 환불 반영 | 정산 전 환불 vs 정산 후 환불 처리 방식 차이 |
| 수수료 계산 | 카테고리별, 판매자 등급별 수수료율 차등 |
| 배치 재실행 | 동일 기간 재정산 시 중복 지급 방지 |
| 정산 기간 경계 | 23:59:59에 결제된 주문은 어느 정산에 포함? |

### 설계 방향

- **이벤트 소싱 아님**: 단순 스냅샷 기반 정산
- **실시간 아님**: 배치 기반 일/주 단위 정산
- **완벽한 자동화 아님**: 수동 조정(Adjustment) 가능

> 1년차 포트폴리오 관점: 복잡한 이벤트 소싱보다 **명확한 스냅샷 모델**로 설계 의도를 드러낸다.

---

## 2. Bounded Context

### Context Map

```
┌─────────────────────────────────────────────────────────────┐
│                      Upstream Contexts                       │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐          │
│  │    Order    │  │   Payment   │  │   Refund    │          │
│  │   Context   │  │   Context   │  │   Context   │          │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘          │
│         │                │                │                  │
│         └────────────────┼────────────────┘                  │
│                          │                                   │
│                          ▼                                   │
│              ┌───────────────────────┐                       │
│              │   Anti-Corruption     │                       │
│              │       Layer           │                       │
│              └───────────┬───────────┘                       │
└──────────────────────────┼──────────────────────────────────┘
                           │
                           ▼
┌──────────────────────────────────────────────────────────────┐
│                   Settlement Context                          │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  Settlement    SettlementItem    SettlementJobExecution │ │
│  │  Cycle         Target            ...                    │ │
│  └─────────────────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────────────────┘
```

### 2.1 Order/Payment/Refund Context (Upstream)

**역할**: 주문, 결제, 환불의 원천 데이터를 관리

**Settlement Context와의 관계**: **Conformist (준수자)**
- 정산 컨텍스트는 Upstream의 데이터 구조를 그대로 따른다
- Upstream 변경 시 정산 로직도 영향받음을 인지

**Settlement Context가 필요로 하는 데이터**:

| Upstream Entity | 필요 필드 | 용도 |
|-----------------|-----------|------|
| Order | orderId, sellerId, orderStatus, orderedAt | 정산 대상 식별 |
| OrderItem | itemId, productId, quantity, price, commission | 정산 금액 계산 |
| Payment | paymentId, paidAmount, paidAt, status | 결제 확정 여부 |
| Refund | refundId, refundAmount, refundedAt, orderItemId | 차감 금액 계산 |

### 2.2 Settlement Context (정산 전용)

**역할**: 정산 주기에 따라 판매자별 지급 금액을 산출하고 이력 관리

**핵심 책임**:
1. 정산 대상 OrderItem 집계
2. 환불 금액 차감
3. 수수료 계산
4. 정산 스냅샷 생성 및 저장
5. 배치 실행 이력 관리

**Upstream과의 경계 (Anti-Corruption Layer)**:

```java
// Settlement Context는 Upstream의 Order를 직접 참조하지 않는다
// 대신 필요한 데이터만 추출한 SettlementTarget으로 변환

// Bad: Upstream 엔티티 직접 의존
public class Settlement {
    private List<Order> orders;  // X - Upstream 변경에 취약
}

// Good: 정산에 필요한 정보만 추출
public class Settlement {
    private List<SettlementItem> items;  // O - 정산 도메인 자체 모델
}
```

### Context 간 통신 방식

| 방식 | 선택 | 이유 |
|------|------|------|
| 동기 API 호출 | X | 배치 처리 시 대량 호출 부담 |
| 이벤트 구독 | X | 1년차 포트폴리오에 과한 복잡도 |
| **배치 시점 DB 조회** | O | 단순하고 디버깅 용이 |

> 설계 의사결정: 이벤트 기반 아키텍처가 더 "있어 보이지만", 배치 정산에서는 **시점 기준 DB 조회**가 더 명확하다.

---

## 3. 용어 사전 (Ubiquitous Language)

### 3.1 Settlement Cycle (정산 주기)

**정의**: 정산이 실행되는 주기. DAILY(일별) 또는 WEEKLY(주별).

**왜 필요한가**:
- 판매자 등급/계약에 따라 정산 주기가 다를 수 있음
- "이 판매자는 매일 정산" vs "저 판매자는 주 1회 정산"

**예시**:

| Cycle | 정산 실행일 | 정산 대상 기간 |
|-------|------------|----------------|
| DAILY | 매일 02:00 | 전일 00:00:00 ~ 23:59:59 |
| WEEKLY | 매주 월요일 02:00 | 전주 월~일 |

**코드 표현**:

```java
public enum SettlementCycle {
    DAILY,
    WEEKLY;

    public LocalDate calculatePeriodStart(LocalDate baseDate) {
        return switch (this) {
            case DAILY -> baseDate.minusDays(1);
            case WEEKLY -> baseDate.minusWeeks(1).with(DayOfWeek.MONDAY);
        };
    }

    public LocalDate calculatePeriodEnd(LocalDate baseDate) {
        return switch (this) {
            case DAILY -> baseDate.minusDays(1);
            case WEEKLY -> baseDate.minusWeeks(1).with(DayOfWeek.SUNDAY);
        };
    }
}
```

---

### 3.2 Settlement Unit (정산 단위)

**정의**: 정산의 최소 식별 단위. `Seller + Cycle + Period(기간)`의 조합.

**왜 필요한가**:
- 같은 날짜라도 판매자마다 별도 정산
- 같은 판매자라도 기간이 다르면 별도 정산
- **중복 정산 방지의 핵심 키**

**식별자 구성**:

```
SettlementUnit = {sellerId} + {cycle} + {periodStart} + {periodEnd}

예시: "SELLER_001_DAILY_2025-01-15_2025-01-15"
      "SELLER_002_WEEKLY_2025-01-06_2025-01-12"
```

**불변 조건 (Invariant)**:
- 동일한 Settlement Unit에 대해 **CONFIRMED 상태의 Settlement는 하나만 존재**해야 한다
- 재정산 시 기존 Settlement는 CANCELED 처리 후 새로 생성

```java
// 중복 방지를 위한 유니크 제약
@Table(uniqueConstraints = {
    @UniqueConstraint(
        name = "uk_settlement_unit",
        columnNames = {"seller_id", "cycle", "period_start", "period_end", "status"}
    )
})
public class Settlement {
    // ...
}
```

---

### 3.3 Settlement Target (정산 대상)

**정의**: 특정 정산 기간 내에 포함되는 OrderItem의 집합.

**왜 필요한가**:
- 정산 금액 계산의 원천 데이터
- "이번 정산에 어떤 주문들이 포함되었나?" 추적 가능

**대상 선정 기준**:

```sql
-- 정산 대상 조회 쿼리 (개념적)
SELECT oi.*
FROM order_item oi
JOIN orders o ON oi.order_id = o.id
JOIN payment p ON o.id = p.order_id
WHERE o.seller_id = :sellerId
  AND p.status = 'CONFIRMED'           -- 결제 확정된 것만
  AND p.paid_at >= :periodStart        -- 기간 시작
  AND p.paid_at < :periodEnd + 1 day   -- 기간 종료 (exclusive)
  AND oi.id NOT IN (                   -- 이미 정산된 것 제외
      SELECT si.source_id
      FROM settlement_item si
      WHERE si.settlement_status = 'CONFIRMED'
  )
```

**경계 케이스 처리**:

| 케이스 | 처리 방식 |
|--------|-----------|
| 23:59:59.999 결제 | paid_at 기준으로 해당 일자 정산에 포함 |
| 정산 실행 중 새 결제 발생 | 다음 정산에 포함 (조회 시점 기준) |
| 부분 환불된 주문 | 원 금액으로 SALE 항목 생성, 환불분은 REFUND 항목으로 별도 생성 |

---

### 3.4 Settlement (정산)

**정의**: 특정 Settlement Unit에 대한 정산 결과 스냅샷.

**왜 필요한가**:
- 정산 시점의 금액을 **불변하게 보관**
- 나중에 원천 데이터(Order)가 변경되어도 정산 금액은 유지
- 감사(Audit) 및 분쟁 해결의 근거

**상태 전이**:

```
┌──────────┐    확정    ┌───────────┐    지급완료   ┌──────────┐
│ PENDING  │ ─────────▶ │ CONFIRMED │ ───────────▶ │   PAID   │
└──────────┘            └───────────┘              └──────────┘
      │                       │
      │ 취소                   │ 재정산
      ▼                       ▼
┌──────────┐            ┌───────────┐
│ CANCELED │            │ CANCELED  │ ──▶ 새 Settlement 생성
└──────────┘            └───────────┘
```

**핵심 필드**:

```java
@Entity
public class Settlement {
    @Id
    private Long id;

    private Long sellerId;

    @Enumerated(EnumType.STRING)
    private SettlementCycle cycle;

    private LocalDate periodStart;
    private LocalDate periodEnd;

    private BigDecimal totalSaleAmount;      // 총 판매금액
    private BigDecimal totalRefundAmount;    // 총 환불금액
    private BigDecimal totalCommission;      // 총 수수료
    private BigDecimal totalAdjustment;      // 총 조정금액
    private BigDecimal netAmount;            // 최종 지급액

    @Enumerated(EnumType.STRING)
    private SettlementStatus status;

    private LocalDateTime createdAt;
    private LocalDateTime confirmedAt;
    private LocalDateTime paidAt;

    @OneToMany(mappedBy = "settlement", cascade = CascadeType.ALL)
    private List<SettlementItem> items = new ArrayList<>();
}
```

**불변 조건 (Invariant)**:

```java
// Invariant 1: netAmount 계산 정합성
assert netAmount.equals(
    totalSaleAmount
        .subtract(totalRefundAmount)
        .subtract(totalCommission)
        .add(totalAdjustment)
);

// Invariant 2: CONFIRMED 후에는 금액 변경 불가
if (status == CONFIRMED || status == PAID) {
    throw new IllegalStateException("확정된 정산은 수정할 수 없습니다");
}

// Invariant 3: netAmount는 음수일 수 있음 (환불이 판매보다 많은 경우)
// 단, 이 경우 다음 정산에서 차감하거나 별도 처리 필요
```

---

### 3.5 SettlementItem (정산 항목)

**정의**: Settlement를 구성하는 개별 항목. 유형에 따라 SALE, REFUND, ADJUSTMENT로 구분.

**왜 필요한가**:
- 정산 금액의 **상세 내역 추적**
- "이 정산이 왜 이 금액인가?"에 대한 근거
- 분쟁 시 원천 데이터(OrderItem, Refund)와 매핑 가능

**유형별 특성**:

| Type | 금액 부호 | 원천 데이터 | 설명 |
|------|-----------|-------------|------|
| SALE | + | OrderItem | 판매로 인한 수익 |
| REFUND | - | Refund | 환불로 인한 차감 |
| ADJUSTMENT | +/- | 수동 입력 | 수수료 조정, 프로모션 보전 등 |

**코드 표현**:

```java
@Entity
public class SettlementItem {
    @Id
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "settlement_id")
    private Settlement settlement;

    @Enumerated(EnumType.STRING)
    private SettlementItemType type;  // SALE, REFUND, ADJUSTMENT

    private Long sourceId;            // OrderItem.id 또는 Refund.id
    private String sourceType;        // "ORDER_ITEM" 또는 "REFUND"

    private BigDecimal amount;        // 항목 금액 (REFUND는 양수로 저장, 계산 시 차감)
    private BigDecimal commission;    // 수수료
    private BigDecimal netAmount;     // amount - commission

    private String description;       // ADJUSTMENT의 경우 사유

    private LocalDateTime sourceCreatedAt;  // 원천 데이터 생성 시점
}
```

**불변 조건 (Invariant)**:

```java
// Invariant 1: SALE, REFUND는 반드시 sourceId가 있어야 함
if (type == SALE || type == REFUND) {
    assert sourceId != null;
}

// Invariant 2: ADJUSTMENT는 description 필수
if (type == ADJUSTMENT) {
    assert description != null && !description.isBlank();
}

// Invariant 3: 동일 sourceId + sourceType 중복 불가 (같은 정산 내)
// - 같은 OrderItem이 한 정산에 두 번 들어가면 안 됨
```

---

### 3.6 SettlementJobExecution (정산 배치 실행 이력)

**정의**: 정산 배치 Job의 실행 이력. 언제, 어떤 파라미터로, 어떤 결과가 나왔는지 기록.

**왜 필요한가**:
- **배치 재실행 시 중복 방지** 판단 근거
- 장애 발생 시 디버깅
- "어제 정산이 제대로 돌았나?" 확인

**핵심 필드**:

```java
@Entity
public class SettlementJobExecution {
    @Id
    private Long id;

    private String jobName;              // "DailySettlementJob"
    private LocalDate targetDate;        // 정산 대상 일자

    @Enumerated(EnumType.STRING)
    private SettlementCycle cycle;

    @Enumerated(EnumType.STRING)
    private JobExecutionStatus status;   // RUNNING, COMPLETED, FAILED

    private Integer totalSellerCount;    // 정산 대상 판매자 수
    private Integer successCount;        // 성공
    private Integer failCount;           // 실패
    private Integer skipCount;           // 스킵 (이미 정산됨)

    private LocalDateTime startedAt;
    private LocalDateTime completedAt;

    private String errorMessage;         // 실패 시 에러 내용

    @Lob
    private String executionLog;         // 상세 로그 (선택적)
}
```

**멱등성 보장 방식**:

```java
// 배치 시작 전 체크
public boolean canExecute(LocalDate targetDate, SettlementCycle cycle) {
    return !jobExecutionRepository.existsByTargetDateAndCycleAndStatus(
        targetDate,
        cycle,
        JobExecutionStatus.COMPLETED
    );
}

// 개별 판매자 정산 시 체크
public boolean isAlreadySettled(Long sellerId, LocalDate periodStart, LocalDate periodEnd) {
    return settlementRepository.existsBySellerIdAndPeriodAndStatusIn(
        sellerId,
        periodStart,
        periodEnd,
        List.of(SettlementStatus.CONFIRMED, SettlementStatus.PAID)
    );
}
```

**재실행 시나리오**:

| 시나리오 | 처리 방식 |
|----------|-----------|
| 동일 날짜 배치 재실행 | COMPLETED 상태면 스킵, FAILED면 재시도 |
| 특정 판매자만 재정산 | 기존 Settlement를 CANCELED 처리 후 새로 생성 |
| 전체 재정산 (드묾) | 관리자 승인 후 모든 기존 Settlement CANCELED 처리 |

---

## 4. Aggregate & Invariants 개요

### Aggregate 식별

```
┌─────────────────────────────────────────────────┐
│           Settlement Aggregate                   │
│  ┌─────────────────────────────────────────┐    │
│  │            Settlement (Root)             │    │
│  │  - id                                    │    │
│  │  - sellerId                              │    │
│  │  - cycle, periodStart, periodEnd         │    │
│  │  - amounts (sale, refund, commission...) │    │
│  │  - status                                │    │
│  │                                          │    │
│  │  ┌─────────────────────────────────┐    │    │
│  │  │      SettlementItem (1..N)      │    │    │
│  │  │  - type, sourceId, amount       │    │    │
│  │  └─────────────────────────────────┘    │    │
│  └─────────────────────────────────────────┘    │
└─────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────┐
│      SettlementJobExecution (별도 Aggregate)     │
│  - 배치 실행 단위로 독립 관리                      │
│  - Settlement와 직접 연관 없음 (날짜 기준 조회)    │
└─────────────────────────────────────────────────┘
```

### 전체 불변 조건 요약

| 대상 | 불변 조건 | 검증 시점 |
|------|-----------|-----------|
| Settlement | netAmount = sale - refund - commission + adjustment | 생성/수정 시 |
| Settlement | 동일 Unit에 CONFIRMED는 최대 1개 | 상태 변경 시 |
| Settlement | CONFIRMED 이후 금액 변경 불가 | 수정 시도 시 |
| SettlementItem | SALE/REFUND는 sourceId 필수 | 생성 시 |
| SettlementItem | 같은 Settlement 내 sourceId 중복 불가 | 생성 시 |
| SettlementItem | ADJUSTMENT는 description 필수 | 생성 시 |
| JobExecution | COMPLETED 상태 Job은 재실행 불가 | 배치 시작 시 |

### 도메인 서비스

```java
// 정산 생성은 복잡한 로직이므로 Domain Service로 분리
@Service
@RequiredArgsConstructor
public class SettlementCalculator {

    public Settlement calculate(Long sellerId, SettlementCycle cycle,
                                LocalDate periodStart, LocalDate periodEnd) {
        // 1. 정산 대상 OrderItem 조회
        List<SettlementTarget> targets = findSettlementTargets(sellerId, periodStart, periodEnd);

        // 2. 기간 내 환불 조회
        List<RefundInfo> refunds = findRefunds(sellerId, periodStart, periodEnd);

        // 3. Settlement 생성
        Settlement settlement = Settlement.create(sellerId, cycle, periodStart, periodEnd);

        // 4. SALE 항목 추가
        targets.forEach(target ->
            settlement.addItem(SettlementItem.sale(target))
        );

        // 5. REFUND 항목 추가
        refunds.forEach(refund ->
            settlement.addItem(SettlementItem.refund(refund))
        );

        // 6. 금액 계산 (Invariant 검증 포함)
        settlement.calculateTotals();

        return settlement;
    }
}
```

---

## 5. 다음 단계

이 도메인 정의를 바탕으로 다음 문서를 작성할 예정:

- [ ] ERD 및 테이블 설계
- [ ] API 설계 (정산 조회, 수동 조정, 재정산)
- [ ] 배치 Job 설계 (Spring Batch)
- [ ] 환불 반영 방식 상세 설계

---

## 관련 문서

- [[사이드 프로젝트 공통 가이드]]
