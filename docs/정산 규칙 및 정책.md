---
title: 마켓플레이스 정산 시스템 - 정산 규칙 및 정책
created: 2025-12-01
updated: 2025-12-01
tags: [project, settlement, policy, calculation]
category: Projects
status: draft
---

# 정산 규칙 및 정책

## 개요

이 문서는 마켓플레이스 판매자 정산 시스템의 **정산 규칙과 금액 계산 정책**을 정의한다. 운영 환경에서 "왜 이 금액이 정산되었는가?"에 대한 근거 문서로 활용된다.

---

## 1. 정산 기준 시점

### 1.1 기준 시점 정의

정산 대상을 선정할 때 사용하는 기준 시점은 **Payment.paidAt (결제 완료 시점)**이다.

| 후보 시점 | 선택 | 이유 |
|-----------|------|------|
| Order.orderedAt | X | 결제 실패 주문도 포함될 위험 |
| **Payment.paidAt** | **O** | 실제 돈이 들어온 시점 = 정산 근거 |
| Order.completedAt | X | 배송 완료까지 대기 시 정산 지연 |

### 1.2 정산 기간 범위

```
정산 대상 조건:
  periodStart <= Payment.paidAt < periodEnd + 1일

예시 (2025-01-15 일별 정산):
  periodStart = 2025-01-15 00:00:00.000
  periodEnd   = 2025-01-15 23:59:59.999

  포함: 2025-01-15 00:00:00.000 ~ 2025-01-15 23:59:59.999
  제외: 2025-01-16 00:00:00.000 ~
```

### 1.3 타임존 정책

| 항목 | 정책 |
|------|------|
| 서버 타임존 | Asia/Seoul (KST, UTC+9) |
| DB 저장 | TIMESTAMP (UTC 저장, 조회 시 KST 변환) |
| 정산 기간 기준 | KST 기준 00:00:00 ~ 23:59:59 |

```java
// 정산 기간 계산 시 타임존 명시
ZoneId KOREA_ZONE = ZoneId.of("Asia/Seoul");

LocalDateTime periodStart = targetDate.atStartOfDay();  // 00:00:00
LocalDateTime periodEnd = targetDate.atTime(LocalTime.MAX);  // 23:59:59.999999999
```

### 1.4 경계 케이스 처리

| 케이스 | 처리 방식 | 근거 |
|--------|-----------|------|
| 23:59:59.999 결제 | 해당 일자 정산에 포함 | periodEnd 이하 조건 |
| 00:00:00.000 결제 | 해당 일자 정산에 포함 | periodStart 이상 조건 |
| 정산 배치 실행 중 결제 발생 | 다음 정산에 포함 | 배치 시작 시점 기준 조회 |

---

## 2. 정산 대상 선정 규칙

### 2.1 포함 조건 (AND)

정산 대상이 되려면 **모든 조건**을 만족해야 한다:

- [x] `Payment.status = 'CONFIRMED'` (결제 확정)
- [x] `Payment.paidAt`이 정산 기간 내에 포함
- [x] `Order.status IN ('PAID', 'SHIPPED', 'DELIVERED', 'COMPLETED')`
- [x] `OrderItem.status != 'CANCELED'` (취소되지 않은 상품)
- [x] `Seller.status = 'ACTIVE'` (활성 판매자)
- [x] 해당 OrderItem이 **이전 정산에 포함되지 않음** (중복 방지)

### 2.2 제외 조건 (OR)

다음 중 **하나라도** 해당하면 정산 대상에서 제외:

- [ ] `Payment.status IN ('PENDING', 'FAILED', 'CANCELED')` (미확정 결제)
- [ ] `Order.status = 'CANCELED'` (주문 취소)
- [ ] `OrderItem.status = 'CANCELED'` (상품 취소)
- [ ] `Seller.status IN ('SUSPENDED', 'WITHDRAWN')` (비활성 판매자)
- [ ] 해당 OrderItem이 이미 `CONFIRMED` 상태의 Settlement에 포함됨

### 2.3 정산 대상 조회 쿼리

```sql
-- 정산 대상 OrderItem 조회
SELECT
    oi.id AS order_item_id,
    oi.order_id,
    o.seller_id,
    oi.product_id,
    oi.quantity,
    oi.unit_price,
    oi.total_price,
    p.paid_at
FROM order_item oi
INNER JOIN orders o ON oi.order_id = o.id
INNER JOIN payment p ON o.id = p.order_id
INNER JOIN seller s ON o.seller_id = s.id
WHERE o.seller_id = :sellerId
  AND p.status = 'CONFIRMED'
  AND p.paid_at >= :periodStart
  AND p.paid_at < :periodEndExclusive  -- periodEnd + 1일
  AND o.status IN ('PAID', 'SHIPPED', 'DELIVERED', 'COMPLETED')
  AND oi.status != 'CANCELED'
  AND s.status = 'ACTIVE'
  AND NOT EXISTS (
      SELECT 1
      FROM settlement_item si
      INNER JOIN settlement stl ON si.settlement_id = stl.id
      WHERE si.source_id = oi.id
        AND si.source_type = 'ORDER_ITEM'
        AND stl.status IN ('CONFIRMED', 'PAID')
  )
ORDER BY p.paid_at ASC;
```

### 2.4 상태별 정산 처리

```
주문 상태 흐름:
PENDING → PAID → SHIPPED → DELIVERED → COMPLETED
    ↓        ↓       ↓          ↓
 CANCELED  CANCELED CANCELED  CANCELED (환불)

정산 대상 여부:
- PENDING: X (결제 미완료)
- PAID ~ COMPLETED: O (정산 대상)
- CANCELED: X (정산 제외, 이미 정산된 경우 환불 처리)
```

---

## 3. 환불 반영 정책

### 3.1 기본 원칙

> **환불은 "환불 발생 시점(Refund.refundedAt)"이 속한 정산 주기에 REFUND 항목으로 반영한다.**

```
시나리오:
- 1/10: 주문 결제 완료 (10,000원) → 1/10 정산에 SALE +10,000원
- 1/15: 환불 발생 (10,000원)      → 1/15 정산에 REFUND -10,000원

결과:
- 1/10 정산: +10,000원 (변경 없음)
- 1/15 정산: -10,000원 (환불 차감)
```

### 3.2 환불 유형별 처리

| 환불 유형 | 처리 방식 | 정산 항목 |
|-----------|-----------|-----------|
| 전체 환불 | 주문 전체 금액 차감 | REFUND (전액) |
| 부분 환불 (금액) | 환불 금액만 차감 | REFUND (환불 금액) |
| 부분 환불 (수량) | 환불 수량 × 단가 차감 | REFUND (수량 × 단가) |

### 3.3 환불 반영 조건

환불이 정산에 반영되려면:

- [x] `Refund.status = 'COMPLETED'` (환불 완료)
- [x] `Refund.refundedAt`이 정산 기간 내
- [x] 원본 OrderItem이 **이미 정산된 상태** (SALE 항목이 존재)
- [x] 해당 Refund가 **이전 정산에 반영되지 않음**

### 3.4 환불 대상 조회 쿼리

```sql
-- 정산 기간 내 환불 조회
SELECT
    r.id AS refund_id,
    r.order_item_id,
    r.refund_type,          -- FULL, PARTIAL_AMOUNT, PARTIAL_QUANTITY
    r.refund_amount,
    r.refund_quantity,
    r.refunded_at,
    oi.unit_price
FROM refund r
INNER JOIN order_item oi ON r.order_item_id = oi.id
INNER JOIN orders o ON oi.order_id = o.id
WHERE o.seller_id = :sellerId
  AND r.status = 'COMPLETED'
  AND r.refunded_at >= :periodStart
  AND r.refunded_at < :periodEndExclusive
  AND NOT EXISTS (
      SELECT 1
      FROM settlement_item si
      INNER JOIN settlement stl ON si.settlement_id = stl.id
      WHERE si.source_id = r.id
        AND si.source_type = 'REFUND'
        AND stl.status IN ('CONFIRMED', 'PAID')
  )
ORDER BY r.refunded_at ASC;
```

### 3.5 환불 시점에 따른 처리

```
Case 1: 정산 전 환불 (같은 정산 주기 내)
─────────────────────────────────────────
  1/15 09:00 결제 → 정산 대상
  1/15 15:00 환불 → 환불 대상
  1/15 정산: SALE +10,000 / REFUND -10,000 = 0원

Case 2: 정산 후 환불 (다른 정산 주기)
─────────────────────────────────────────
  1/15 09:00 결제 → 1/15 정산 SALE +10,000
  1/20 15:00 환불 → 1/20 정산 REFUND -10,000

Case 3: 정산 확정 후 환불 (이미 지급된 경우)
─────────────────────────────────────────
  1/15 정산 SALE +10,000 (PAID 상태)
  1/20 환불 발생 → 1/20 정산 REFUND -10,000
  → 다음 정산에서 차감되거나, 정산 금액이 음수가 될 수 있음
```

### 3.6 음수 정산 처리

환불이 판매보다 많아 정산 금액이 음수인 경우:

| 처리 방식 | 설명 | 선택 |
|-----------|------|------|
| 다음 정산 이월 | 음수 금액을 다음 정산에서 차감 | X (복잡도 증가) |
| **음수 정산 허용** | 해당 정산을 음수로 확정, 별도 정산 | **O** |
| 즉시 청구 | 판매자에게 별도 청구 | X (1차 MVP 범위 외) |

```java
// 음수 정산 허용
public Settlement calculate(...) {
    BigDecimal netAmount = totalSale
        .subtract(totalRefund)
        .subtract(totalCommission);

    // 음수 허용 - 별도 처리 플래그 설정
    if (netAmount.compareTo(BigDecimal.ZERO) < 0) {
        settlement.markAsNegative();
    }

    return settlement;
}
```

---

## 4. 금액 계산 공식

### 4.1 수수료 정책

| 구분 | 수수료율 | 비고 |
|------|----------|------|
| 기본 수수료 | 10% | 전 카테고리 기본 |
| 프리미엄 판매자 | 8% | 월 매출 1억 이상 |
| 신규 판매자 프로모션 | 5% | 가입 후 3개월 |

> MVP에서는 **고정 10% 수수료**로 단순화. 추후 카테고리별/등급별 차등 적용 확장.

### 4.2 OrderItem 기준 금액 계산

```
┌─────────────────────────────────────────────────────────────┐
│                    OrderItem 금액 계산                        │
├─────────────────────────────────────────────────────────────┤
│  item_gross_amount = unit_price × quantity                  │
│                    = 상품 단가 × 수량                         │
│                                                             │
│  item_commission_amount = item_gross_amount × commission_rate│
│                         = 총액 × 수수료율 (10%)               │
│                                                             │
│  item_tax_amount = item_commission_amount × 0.1             │
│                  = 수수료에 대한 부가세 (10%)                  │
│                  = (수수료는 플랫폼 매출이므로 VAT 발생)        │
│                                                             │
│  item_net_amount = item_gross_amount                        │
│                    - item_commission_amount                 │
│                    - item_tax_amount                        │
│                  = 판매자 실수령액                            │
└─────────────────────────────────────────────────────────────┘
```

**계산 예시**:

```
상품 단가: 10,000원, 수량: 2개, 수수료율: 10%

item_gross_amount      = 10,000 × 2 = 20,000원
item_commission_amount = 20,000 × 0.10 = 2,000원
item_tax_amount        = 2,000 × 0.10 = 200원
item_net_amount        = 20,000 - 2,000 - 200 = 17,800원
```

### 4.3 Refund 기준 금액 계산

```
┌─────────────────────────────────────────────────────────────┐
│                    Refund 금액 계산                          │
├─────────────────────────────────────────────────────────────┤
│  전체 환불:                                                  │
│    refund_gross_amount = 원본 item_gross_amount             │
│                                                             │
│  부분 환불 (금액):                                            │
│    refund_gross_amount = 환불 요청 금액                       │
│                                                             │
│  부분 환불 (수량):                                            │
│    refund_gross_amount = unit_price × refund_quantity       │
│                                                             │
│  ─────────────────────────────────────────────────────────  │
│  refund_commission_amount = refund_gross_amount × rate      │
│                           = 환불에 따른 수수료 환급           │
│                                                             │
│  refund_tax_amount = refund_commission_amount × 0.1         │
│                                                             │
│  refund_net_amount = refund_gross_amount                    │
│                      - refund_commission_amount             │
│                      - refund_tax_amount                    │
│                    = 판매자에게서 차감할 금액                  │
└─────────────────────────────────────────────────────────────┘
```

**환불 시 수수료 처리**:

| 정책 옵션 | 설명 | 선택 |
|-----------|------|------|
| 수수료 환급 | 환불 시 수수료도 판매자에게 돌려줌 | **O** |
| 수수료 미환급 | 환불되어도 수수료는 플랫폼이 보유 | X |

```java
// 환불 시 수수료 환급 정책
// SALE: +20,000 (수수료 -2,000)
// REFUND: -20,000 (수수료 +2,000 환급)
// → 판매자 입장에서 환불 시 수수료도 돌려받음
```

### 4.4 Settlement 단위 총합 공식

```
┌─────────────────────────────────────────────────────────────┐
│                  Settlement 총합 계산                        │
├─────────────────────────────────────────────────────────────┤
│  gross_sales_amount = Σ (SALE 항목의 item_gross_amount)     │
│                                                             │
│  commission_amount = Σ (SALE 항목의 item_commission_amount) │
│                      - Σ (REFUND 항목의 refund_commission)  │
│                    = 순 수수료 (환불에 따른 수수료 환급 반영)  │
│                                                             │
│  tax_amount = Σ (SALE 항목의 item_tax_amount)               │
│               - Σ (REFUND 항목의 refund_tax_amount)         │
│                                                             │
│  refund_amount = Σ (REFUND 항목의 refund_gross_amount)      │
│                                                             │
│  adjustment_amount = Σ (ADJUSTMENT 항목의 amount)           │
│                    = 수동 조정 금액 (+/-)                     │
│                                                             │
│  ─────────────────────────────────────────────────────────  │
│  payout_amount = gross_sales_amount                         │
│                  - refund_amount                            │
│                  - commission_amount                        │
│                  - tax_amount                               │
│                  + adjustment_amount                        │
│                = 최종 판매자 지급액                           │
└─────────────────────────────────────────────────────────────┘
```

**전체 계산 예시**:

```
[SALE 항목]
- OrderItem A: gross 20,000 / commission 2,000 / tax 200 / net 17,800
- OrderItem B: gross 30,000 / commission 3,000 / tax 300 / net 26,700

[REFUND 항목]
- Refund A: gross 10,000 / commission 1,000 / tax 100 / net 8,900

[ADJUSTMENT 항목]
- 프로모션 보전: +500

[Settlement 총합]
gross_sales_amount = 20,000 + 30,000 = 50,000
commission_amount  = (2,000 + 3,000) - 1,000 = 4,000
tax_amount         = (200 + 300) - 100 = 400
refund_amount      = 10,000
adjustment_amount  = +500

payout_amount = 50,000 - 10,000 - 4,000 - 400 + 500 = 36,100원
```

### 4.5 BigDecimal & RoundingMode 정책

#### 사용 원칙

```java
// 금액 계산에는 반드시 BigDecimal 사용
// double/float 사용 금지 (부동소수점 오차 발생)

// Bad
double amount = 10000 * 0.1;  // 999.9999999... 가능성

// Good
BigDecimal amount = new BigDecimal("10000")
    .multiply(new BigDecimal("0.1"));
```

#### RoundingMode 정책

| 계산 항목 | RoundingMode | 소수점 처리 | 이유 |
|-----------|--------------|-------------|------|
| 수수료 계산 | HALF_UP | 소수점 버림 (원 단위) | 판매자 유리 |
| 세금 계산 | HALF_UP | 소수점 버림 (원 단위) | 세법 일반 원칙 |
| 최종 지급액 | HALF_UP | 소수점 버림 (원 단위) | 은행 송금 단위 |

```java
public class MoneyCalculator {

    private static final int SCALE = 0;  // 소수점 없음 (원 단위)
    private static final RoundingMode ROUNDING_MODE = RoundingMode.HALF_UP;

    public static BigDecimal calculateCommission(BigDecimal grossAmount,
                                                  BigDecimal commissionRate) {
        return grossAmount
            .multiply(commissionRate)
            .setScale(SCALE, ROUNDING_MODE);
    }

    public static BigDecimal calculateTax(BigDecimal commissionAmount,
                                          BigDecimal taxRate) {
        return commissionAmount
            .multiply(taxRate)
            .setScale(SCALE, ROUNDING_MODE);
    }
}
```

#### 정밀도 검증

```java
// Invariant: 총합 검증
public void validateTotals(Settlement settlement) {
    BigDecimal calculatedPayout = settlement.getGrossSalesAmount()
        .subtract(settlement.getRefundAmount())
        .subtract(settlement.getCommissionAmount())
        .subtract(settlement.getTaxAmount())
        .add(settlement.getAdjustmentAmount());

    if (!calculatedPayout.equals(settlement.getPayoutAmount())) {
        throw new SettlementCalculationException(
            "정산 금액 불일치: 계산값=" + calculatedPayout +
            ", 저장값=" + settlement.getPayoutAmount()
        );
    }
}
```

---

## 5. 멱등성 & 재실행 정책

### 5.1 중복 정산 방지 키

**Unique Key 구성**:

```
Settlement 유니크 키 = seller_id + cycle + period_start + period_end + status

단, status가 CONFIRMED 또는 PAID인 경우에만 유니크 제약
→ 같은 기간에 PENDING은 여러 개 가능 (재계산 중)
→ CONFIRMED/PAID는 하나만 존재
```

**테이블 제약조건**:

```sql
-- Partial Unique Index (PostgreSQL)
CREATE UNIQUE INDEX uk_settlement_confirmed
ON settlement (seller_id, cycle, period_start, period_end)
WHERE status IN ('CONFIRMED', 'PAID');

-- MySQL (함수 기반)
ALTER TABLE settlement
ADD CONSTRAINT uk_settlement_unit
UNIQUE (seller_id, cycle, period_start, period_end, status_confirmed_flag);

-- status_confirmed_flag: CONFIRMED/PAID면 1, 그 외 NULL (NULL은 유니크 제약 무시)
```

### 5.2 SettlementItem 중복 방지

```sql
-- 같은 Settlement 내 동일 원천 데이터 중복 방지
CREATE UNIQUE INDEX uk_settlement_item_source
ON settlement_item (settlement_id, source_type, source_id);
```

### 5.3 재실행 시나리오별 처리

#### 시나리오 1: 배치 실패 후 재실행

```
상황: 1/15 정산 배치가 50% 진행 후 실패
처리:
  1. SettlementJobExecution.status = FAILED 확인
  2. PENDING 상태의 Settlement 삭제
  3. 배치 처음부터 재실행
```

```java
@Transactional
public void retryFailedBatch(LocalDate targetDate, SettlementCycle cycle) {
    // 1. 실패한 Job 확인
    SettlementJobExecution failedJob = jobExecutionRepository
        .findByTargetDateAndCycleAndStatus(targetDate, cycle, FAILED)
        .orElseThrow();

    // 2. PENDING 상태 Settlement 삭제
    settlementRepository.deleteByPeriodAndStatus(
        failedJob.getPeriodStart(),
        failedJob.getPeriodEnd(),
        SettlementStatus.PENDING
    );

    // 3. 새 Job 실행
    executeSettlementBatch(targetDate, cycle);
}
```

#### 시나리오 2: 확정 전 재계산 (PENDING 상태)

```
상황: 1/15 정산이 PENDING 상태인데, 누락된 주문 발견
처리:
  1. 기존 PENDING Settlement 삭제
  2. 정산 재계산
  3. 새 Settlement 생성 (PENDING)
```

```java
@Transactional
public Settlement recalculatePending(Long settlementId) {
    Settlement existing = settlementRepository.findById(settlementId)
        .orElseThrow();

    if (existing.getStatus() != SettlementStatus.PENDING) {
        throw new IllegalStateException("PENDING 상태만 재계산 가능");
    }

    // 기존 삭제
    settlementRepository.delete(existing);

    // 재계산
    return settlementCalculator.calculate(
        existing.getSellerId(),
        existing.getCycle(),
        existing.getPeriodStart(),
        existing.getPeriodEnd()
    );
}
```

#### 시나리오 3: 확정 후 재정산 (CONFIRMED/PAID 상태)

```
상황: 1/15 정산이 CONFIRMED 상태인데, 정산 오류 발견
처리:
  1. 기존 Settlement 상태를 CANCELED로 변경
  2. 취소 사유 기록
  3. 정산 재계산
  4. 새 Settlement 생성 (PENDING → CONFIRMED)
```

```java
@Transactional
public Settlement reSettleConfirmed(Long settlementId, String cancelReason) {
    Settlement existing = settlementRepository.findById(settlementId)
        .orElseThrow();

    if (existing.getStatus() == SettlementStatus.PAID) {
        throw new IllegalStateException("지급 완료된 정산은 재정산 불가. 조정(Adjustment) 사용");
    }

    // 1. 기존 정산 취소
    existing.cancel(cancelReason);
    settlementRepository.save(existing);

    // 2. 연결된 SettlementItem의 source 해제 (재정산 시 다시 선정되도록)
    // → SettlementItem은 CASCADE로 함께 처리되거나,
    //   source 기준 조회 시 CANCELED Settlement 제외

    // 3. 재계산
    Settlement newSettlement = settlementCalculator.calculate(
        existing.getSellerId(),
        existing.getCycle(),
        existing.getPeriodStart(),
        existing.getPeriodEnd()
    );

    // 4. 기존 정산 참조 기록
    newSettlement.setReSettledFrom(existing.getId());

    return settlementRepository.save(newSettlement);
}
```

#### 시나리오 4: 지급 완료 후 오류 발견 (PAID 상태)

```
상황: 1/15 정산 지급 완료 후 오류 발견
처리:
  - 기존 Settlement는 변경하지 않음 (이력 보존)
  - 다음 정산에 ADJUSTMENT 항목으로 조정
```

```java
@Transactional
public SettlementItem createAdjustment(Long sellerId,
                                        BigDecimal adjustmentAmount,
                                        String reason) {
    // 현재 PENDING 상태의 Settlement에 ADJUSTMENT 추가
    // 없으면 다음 정산 배치에서 처리
    Settlement currentPending = settlementRepository
        .findBySellerIdAndStatus(sellerId, SettlementStatus.PENDING)
        .orElse(null);

    if (currentPending == null) {
        // 대기 중인 정산이 없으면 조정 대기열에 저장
        return adjustmentQueueRepository.save(
            new PendingAdjustment(sellerId, adjustmentAmount, reason)
        );
    }

    return currentPending.addAdjustment(adjustmentAmount, reason);
}
```

### 5.4 재실행 정책 요약

| 기존 상태 | 재실행 가능 | 처리 방식 |
|-----------|-------------|-----------|
| PENDING | O | 삭제 후 재계산 |
| CONFIRMED | O | CANCELED 처리 후 재계산 |
| PAID | X | ADJUSTMENT로 조정 |
| CANCELED | - | 이미 취소됨 (무시) |

### 5.5 멱등성 보장 체크리스트

```
배치 실행 전:
  □ 동일 (seller, cycle, period)에 CONFIRMED/PAID Settlement 존재 여부 확인
  □ 존재하면 해당 판매자 SKIP

정산 항목 생성 시:
  □ 동일 source_id + source_type이 CONFIRMED Settlement에 존재 여부 확인
  □ 존재하면 해당 OrderItem/Refund SKIP

배치 완료 후:
  □ SettlementJobExecution에 실행 결과 기록
  □ 재실행 시 COMPLETED 상태 Job이 있으면 전체 SKIP
```

---

## 6. 검증 쿼리

### 정산 정합성 검증

```sql
-- Settlement 금액 검증
SELECT
    s.id,
    s.seller_id,
    s.gross_sales_amount,
    s.refund_amount,
    s.commission_amount,
    s.tax_amount,
    s.adjustment_amount,
    s.payout_amount,
    (s.gross_sales_amount - s.refund_amount - s.commission_amount
     - s.tax_amount + s.adjustment_amount) AS calculated_payout,
    CASE
        WHEN s.payout_amount = (s.gross_sales_amount - s.refund_amount
             - s.commission_amount - s.tax_amount + s.adjustment_amount)
        THEN 'OK'
        ELSE 'MISMATCH'
    END AS validation_result
FROM settlement s
WHERE s.status = 'CONFIRMED';
```

### 중복 정산 검증

```sql
-- 동일 OrderItem이 여러 정산에 포함되었는지 확인
SELECT
    si.source_id AS order_item_id,
    COUNT(*) AS settlement_count,
    GROUP_CONCAT(s.id) AS settlement_ids
FROM settlement_item si
INNER JOIN settlement s ON si.settlement_id = s.id
WHERE si.source_type = 'ORDER_ITEM'
  AND s.status IN ('CONFIRMED', 'PAID')
GROUP BY si.source_id
HAVING COUNT(*) > 1;
```

---

## 관련 문서

- [[도메인 정의서]]
- [[사이드 프로젝트 공통 가이드]]
