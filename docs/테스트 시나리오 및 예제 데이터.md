---
title: 마켓플레이스 정산 시스템 - 테스트 시나리오 및 예제 데이터
created: 2025-12-01
updated: 2025-12-01
tags: [project, settlement, test, scenario]
category: Projects
status: draft
---

# 테스트 시나리오 및 예제 데이터

## 개요

본 문서는 정산 시스템의 정확성을 검증하기 위한 테스트 시나리오를 정의한다. JUnit 테스트 코드로 직접 변환할 수 있도록 **입력 데이터 → 기대 결과**를 명확히 기술한다.

### 테스트 전제 조건

| 항목 | 값 | 비고 |
|------|----|----|
| 정산 대상 기간 | 2025-01-15 (DAILY) | period_start = period_end |
| 정산 기준 시점 | Payment.paidAt | 결제 완료 시각 |
| 환불 반영 기준 | Refund.refundedAt | 환불 완료 시각 |
| 기본 수수료율 | 10% (0.1) | Seller별 차등 가능 |
| 수수료 부가세율 | 10% (0.1) | 고정 |
| 금액 단위 | 원 (KRW) | 소수점 없음 |
| RoundingMode | HALF_UP | 반올림 |

### 금액 계산 공식

```
[OrderItem 기준]
commission = gross × commission_rate
tax = commission × 0.1
net = gross - commission - tax

[Settlement 기준]
payout = gross_sales - refund - commission - tax + adjustment
```

---

## 테스트 Seller 정의

| Seller ID | Seller Name | 수수료율 | 정산 주기 | 비고 |
|-----------|-------------|----------|-----------|------|
| S001 | 판매자A | 10% | DAILY | 기본 수수료 |
| S002 | 판매자B | 8% | DAILY | 프리미엄 판매자 |
| S003 | 판매자C | 10% | DAILY | 환불 다수 발생 |

---

## 시나리오 1: 정상 판매만 있는 경우

### 케이스명

`TC-S001: 환불 없이 정상 판매만 있는 정산`

### 설명

정산 기간 내에 환불 없이 정상적인 판매만 발생한 가장 기본적인 케이스. 정산 금액 계산 로직의 기본 동작을 검증한다.

### 입력 데이터: 주문/결제

| Order ID | Item ID | Seller | Product | Qty | Unit Price | Total | Paid At | Status |
|----------|---------|--------|---------|-----|------------|-------|---------|--------|
| ORD-001 | ITEM-001 | S001 | 상품A | 2 | 10,000 | 20,000 | 2025-01-15 10:00:00 | CONFIRMED |
| ORD-002 | ITEM-002 | S001 | 상품B | 1 | 30,000 | 30,000 | 2025-01-15 14:30:00 | CONFIRMED |
| ORD-003 | ITEM-003 | S002 | 상품C | 3 | 15,000 | 45,000 | 2025-01-15 09:00:00 | CONFIRMED |
| ORD-004 | ITEM-004 | S002 | 상품D | 1 | 55,000 | 55,000 | 2025-01-15 18:00:00 | CONFIRMED |

### 입력 데이터: 환불

없음

### 기대 결과: Settlement

**Seller S001 (수수료율 10%)**

| 항목 | 계산식 | 금액 |
|------|--------|------|
| gross_sales_amount | 20,000 + 30,000 | **50,000** |
| commission_amount | 50,000 × 0.10 | **5,000** |
| tax_amount | 5,000 × 0.10 | **500** |
| refund_amount | 0 | **0** |
| adjustment_amount | 0 | **0** |
| **payout_amount** | 50,000 - 0 - 5,000 - 500 + 0 | **44,500** |

**Seller S002 (수수료율 8%)**

| 항목 | 계산식 | 금액 |
|------|--------|------|
| gross_sales_amount | 45,000 + 55,000 | **100,000** |
| commission_amount | 100,000 × 0.08 | **8,000** |
| tax_amount | 8,000 × 0.10 | **800** |
| refund_amount | 0 | **0** |
| adjustment_amount | 0 | **0** |
| **payout_amount** | 100,000 - 0 - 8,000 - 800 + 0 | **91,200** |

### 기대 결과: SettlementItem

**S001**

| Item ID | Type | Source ID | Gross | Commission | Tax | Net |
|---------|------|-----------|-------|------------|-----|-----|
| SI-001 | SALE | ITEM-001 | 20,000 | 2,000 | 200 | 17,800 |
| SI-002 | SALE | ITEM-002 | 30,000 | 3,000 | 300 | 26,700 |

**S002**

| Item ID | Type | Source ID | Gross | Commission | Tax | Net |
|---------|------|-----------|-------|------------|-----|-----|
| SI-003 | SALE | ITEM-003 | 45,000 | 3,600 | 360 | 41,040 |
| SI-004 | SALE | ITEM-004 | 55,000 | 4,400 | 440 | 50,160 |

---

## 시나리오 2: 전체 환불이 있는 경우

### 케이스명

`TC-S002: 전체 환불이 포함된 정산`

### 설명

정산 기간 내에 판매와 전체 환불이 함께 발생한 케이스. 환불 시 수수료도 환급되는 정책을 검증한다.

### 입력 데이터: 주문/결제

| Order ID | Item ID | Seller | Product | Qty | Unit Price | Total | Paid At | Status |
|----------|---------|--------|---------|-----|------------|-------|---------|--------|
| ORD-005 | ITEM-005 | S001 | 상품E | 1 | 40,000 | 40,000 | 2025-01-15 11:00:00 | CONFIRMED |
| ORD-006 | ITEM-006 | S001 | 상품F | 2 | 25,000 | 50,000 | 2025-01-15 13:00:00 | CONFIRMED |
| ORD-007 | ITEM-007 | S001 | 상품G | 1 | 30,000 | 30,000 | 2025-01-15 16:00:00 | CONFIRMED |

### 입력 데이터: 환불

| Refund ID | Item ID | Type | Refund Amount | Refunded At | Status |
|-----------|---------|------|---------------|-------------|--------|
| REF-001 | ITEM-006 | FULL | 50,000 | 2025-01-15 20:00:00 | COMPLETED |

### 기대 결과: Settlement

**Seller S001**

| 항목 | 계산식 | 금액 |
|------|--------|------|
| gross_sales_amount | 40,000 + 50,000 + 30,000 | **120,000** |
| refund_amount | 50,000 | **50,000** |
| commission_amount | (120,000 - 50,000) × 0.10 | **7,000** |
| tax_amount | 7,000 × 0.10 | **700** |
| adjustment_amount | 0 | **0** |
| **payout_amount** | 120,000 - 50,000 - 7,000 - 700 + 0 | **62,300** |

> **Note**: 환불 시 해당 금액에 대한 수수료도 환급됨. 순매출(70,000)에 대해서만 수수료 부과.

### 기대 결과: SettlementItem

| Item ID | Type | Source ID | Gross | Commission | Tax | Net |
|---------|------|-----------|-------|------------|-----|-----|
| SI-005 | SALE | ITEM-005 | 40,000 | 4,000 | 400 | 35,600 |
| SI-006 | SALE | ITEM-006 | 50,000 | 5,000 | 500 | 44,500 |
| SI-007 | SALE | ITEM-007 | 30,000 | 3,000 | 300 | 26,700 |
| SI-008 | REFUND | REF-001 | 50,000 | 5,000 | 500 | 44,500 |

---

## 시나리오 3: 부분 환불이 있는 경우

### 케이스명

`TC-S003: 부분 환불(금액/수량)이 포함된 정산`

### 설명

수량 기반 부분 환불과 금액 기반 부분 환불이 혼재된 케이스. 환불 유형별 금액 계산 로직을 검증한다.

### 입력 데이터: 주문/결제

| Order ID | Item ID | Seller | Product | Qty | Unit Price | Total | Paid At | Status |
|----------|---------|--------|---------|-----|------------|-------|---------|--------|
| ORD-008 | ITEM-008 | S003 | 상품H | 5 | 10,000 | 50,000 | 2025-01-15 10:00:00 | CONFIRMED |
| ORD-009 | ITEM-009 | S003 | 상품I | 1 | 80,000 | 80,000 | 2025-01-15 12:00:00 | CONFIRMED |
| ORD-010 | ITEM-010 | S003 | 상품J | 2 | 20,000 | 40,000 | 2025-01-15 15:00:00 | CONFIRMED |

### 입력 데이터: 환불

| Refund ID | Item ID | Type | Qty | Refund Amount | Refunded At | Status |
|-----------|---------|------|-----|---------------|-------------|--------|
| REF-002 | ITEM-008 | PARTIAL_QTY | 2 | 20,000 | 2025-01-15 18:00:00 | COMPLETED |
| REF-003 | ITEM-009 | PARTIAL_AMT | - | 30,000 | 2025-01-15 19:00:00 | COMPLETED |

### 기대 결과: Settlement

**Seller S003 (수수료율 10%)**

| 항목 | 계산식 | 금액 |
|------|--------|------|
| gross_sales_amount | 50,000 + 80,000 + 40,000 | **170,000** |
| refund_amount | 20,000 + 30,000 | **50,000** |
| commission_amount | (170,000 - 50,000) × 0.10 | **12,000** |
| tax_amount | 12,000 × 0.10 | **1,200** |
| adjustment_amount | 0 | **0** |
| **payout_amount** | 170,000 - 50,000 - 12,000 - 1,200 + 0 | **106,800** |

### 기대 결과: SettlementItem

| Item ID | Type | Source ID | Gross | Commission | Tax | Net |
|---------|------|-----------|-------|------------|-----|-----|
| SI-009 | SALE | ITEM-008 | 50,000 | 5,000 | 500 | 44,500 |
| SI-010 | SALE | ITEM-009 | 80,000 | 8,000 | 800 | 71,200 |
| SI-011 | SALE | ITEM-010 | 40,000 | 4,000 | 400 | 35,600 |
| SI-012 | REFUND | REF-002 | 20,000 | 2,000 | 200 | 17,800 |
| SI-013 | REFUND | REF-003 | 30,000 | 3,000 | 300 | 26,700 |

---

## 시나리오 4: 환불이 판매보다 많은 경우 (음수 정산)

### 케이스명

`TC-S004: 음수 정산 (환불 > 판매)`

### 설명

정산 기간 내 환불 금액이 판매 금액을 초과하는 케이스. 이전 기간 판매에 대한 환불이 현재 기간에 반영되는 상황.

### 입력 데이터: 주문/결제

| Order ID | Item ID | Seller | Product | Qty | Unit Price | Total | Paid At | Status |
|----------|---------|--------|---------|-----|------------|-------|---------|--------|
| ORD-011 | ITEM-011 | S001 | 상품K | 1 | 20,000 | 20,000 | 2025-01-15 10:00:00 | CONFIRMED |

> 이전 기간(2025-01-10) 판매 건에 대한 환불이 현재 기간에 발생

### 입력 데이터: 환불

| Refund ID | Item ID | Type | Refund Amount | Refunded At | Status | 원 판매일 |
|-----------|---------|------|---------------|-------------|--------|-----------|
| REF-004 | ITEM-OLD-001 | FULL | 50,000 | 2025-01-15 14:00:00 | COMPLETED | 2025-01-10 |
| REF-005 | ITEM-OLD-002 | FULL | 30,000 | 2025-01-15 16:00:00 | COMPLETED | 2025-01-12 |

### 기대 결과: Settlement

**Seller S001**

| 항목 | 계산식 | 금액 |
|------|--------|------|
| gross_sales_amount | 20,000 | **20,000** |
| refund_amount | 50,000 + 30,000 | **80,000** |
| commission_amount | (20,000 - 80,000) × 0.10 = -6,000 → **0** | **0** |
| tax_amount | 0 × 0.10 | **0** |
| adjustment_amount | 0 | **0** |
| **payout_amount** | 20,000 - 80,000 - 0 - 0 + 0 | **-60,000** |

> **Note**: 음수 정산 발생. 수수료는 음수가 될 수 없으므로 0으로 처리. 실제 지급액 -60,000원은 다음 정산에서 차감하거나 별도 청구.

### 검증 포인트

- `isNegative` 플래그가 `true`로 설정되는지 확인
- 음수 payout_amount가 정상적으로 저장되는지 확인

---

## 시나리오 5: 경계 시간 케이스

### 케이스명

`TC-S005: 정산 기간 경계 시간대 처리`

### 설명

정산 기간의 시작(00:00:00)과 끝(23:59:59)에 걸친 결제/환불 처리를 검증한다.

### 입력 데이터: 주문/결제

| Order ID | Item ID | Seller | Product | Qty | Unit Price | Total | Paid At | Status | 정산 포함 |
|----------|---------|--------|---------|-----|------------|-------|---------|--------|-----------|
| ORD-012 | ITEM-012 | S002 | 상품L | 1 | 10,000 | 10,000 | 2025-01-15 00:00:00.000 | CONFIRMED | O |
| ORD-013 | ITEM-013 | S002 | 상품M | 1 | 20,000 | 20,000 | 2025-01-15 23:59:59.999 | CONFIRMED | O |
| ORD-014 | ITEM-014 | S002 | 상품N | 1 | 30,000 | 30,000 | 2025-01-14 23:59:59.999 | CONFIRMED | X (전일) |
| ORD-015 | ITEM-015 | S002 | 상품O | 1 | 40,000 | 40,000 | 2025-01-16 00:00:00.000 | CONFIRMED | X (익일) |

### 입력 데이터: 환불

없음

### 기대 결과: Settlement

**Seller S002** (정산 기간: 2025-01-15)

| 항목 | 계산식 | 금액 |
|------|--------|------|
| gross_sales_amount | 10,000 + 20,000 (ITEM-012, 013만 포함) | **30,000** |
| commission_amount | 30,000 × 0.08 | **2,400** |
| tax_amount | 2,400 × 0.10 | **240** |
| refund_amount | 0 | **0** |
| **payout_amount** | 30,000 - 0 - 2,400 - 240 + 0 | **27,360** |

### 검증 포인트

- ITEM-014 (전일 23:59:59.999)가 제외되는지 확인
- ITEM-015 (익일 00:00:00.000)가 제외되는지 확인
- ITEM-012 (당일 00:00:00.000)가 포함되는지 확인
- ITEM-013 (당일 23:59:59.999)가 포함되는지 확인

---

## 시나리오 6: 정산 대상에서 제외되는 케이스

### 케이스명

`TC-S006: 정산 제외 조건 검증`

### 설명

결제 미확정, 주문 취소 등 정산 대상에서 제외되어야 하는 케이스를 검증한다.

### 입력 데이터: 주문/결제

| Order ID | Item ID | Seller | Product | Total | Paid At | Payment Status | Order Status | 정산 포함 | 제외 사유 |
|----------|---------|--------|---------|-------|---------|----------------|--------------|-----------|-----------|
| ORD-016 | ITEM-016 | S001 | 상품P | 10,000 | 2025-01-15 10:00 | CONFIRMED | PAID | O | - |
| ORD-017 | ITEM-017 | S001 | 상품Q | 20,000 | 2025-01-15 11:00 | PENDING | PENDING | X | 결제 미확정 |
| ORD-018 | ITEM-018 | S001 | 상품R | 30,000 | 2025-01-15 12:00 | FAILED | CANCELED | X | 결제 실패 |
| ORD-019 | ITEM-019 | S001 | 상품S | 40,000 | 2025-01-15 13:00 | CONFIRMED | CANCELED | X | 주문 취소 |
| ORD-020 | ITEM-020 | S001 | 상품T | 50,000 | 2025-01-15 14:00 | CONFIRMED | COMPLETED | O | - |

### 기대 결과: Settlement

**Seller S001**

| 항목 | 계산식 | 금액 |
|------|--------|------|
| gross_sales_amount | 10,000 + 50,000 (ITEM-016, 020만 포함) | **60,000** |
| commission_amount | 60,000 × 0.10 | **6,000** |
| tax_amount | 6,000 × 0.10 | **600** |
| refund_amount | 0 | **0** |
| **payout_amount** | 60,000 - 0 - 6,000 - 600 + 0 | **53,400** |

### 검증 포인트

- Payment.status = PENDING/FAILED 건 제외
- Order.status = CANCELED 건 제외
- 정상 건(CONFIRMED + PAID/COMPLETED)만 포함

---

## 시나리오 7: 이미 정산된 건 중복 방지

### 케이스명

`TC-S007: 중복 정산 방지 검증`

### 설명

이미 이전 정산에 포함된 OrderItem이 다시 정산되지 않는 것을 검증한다.

### 사전 조건

ITEM-021이 이전 정산(SETTLEMENT-OLD, status=CONFIRMED)에 이미 포함됨

### 입력 데이터: 주문/결제

| Order ID | Item ID | Seller | Product | Total | Paid At | 이전 정산 | 정산 포함 |
|----------|---------|--------|---------|-------|---------|-----------|-----------|
| ORD-021 | ITEM-021 | S001 | 상품U | 30,000 | 2025-01-15 10:00 | SETTLEMENT-OLD (CONFIRMED) | X |
| ORD-022 | ITEM-022 | S001 | 상품V | 40,000 | 2025-01-15 11:00 | 없음 | O |

### 기대 결과: Settlement

**Seller S001**

| 항목 | 계산식 | 금액 |
|------|--------|------|
| gross_sales_amount | 40,000 (ITEM-022만 포함) | **40,000** |
| commission_amount | 40,000 × 0.10 | **4,000** |
| tax_amount | 4,000 × 0.10 | **400** |
| refund_amount | 0 | **0** |
| **payout_amount** | 40,000 - 0 - 4,000 - 400 + 0 | **35,600** |

### 검증 포인트

- CONFIRMED 상태 Settlement에 포함된 ITEM-021 제외
- 새 정산에 ITEM-022만 포함

---

## 시나리오 8: 조정(Adjustment) 포함

### 케이스명

`TC-S008: 수동 조정 항목이 포함된 정산`

### 설명

판매/환불 외에 수동 조정 항목(프로모션 보전, 수수료 조정 등)이 포함된 케이스.

### 입력 데이터: 주문/결제

| Order ID | Item ID | Seller | Product | Total | Paid At |
|----------|---------|--------|---------|-------|---------|
| ORD-023 | ITEM-023 | S002 | 상품W | 100,000 | 2025-01-15 10:00:00 |

### 입력 데이터: 조정

| Adjustment ID | Seller | Type | Amount | Description |
|---------------|--------|------|--------|-------------|
| ADJ-001 | S002 | POSITIVE | +5,000 | 프로모션 보전금 |
| ADJ-002 | S002 | NEGATIVE | -2,000 | 수수료 정산 오류 정정 |

### 기대 결과: Settlement

**Seller S002 (수수료율 8%)**

| 항목 | 계산식 | 금액 |
|------|--------|------|
| gross_sales_amount | 100,000 | **100,000** |
| commission_amount | 100,000 × 0.08 | **8,000** |
| tax_amount | 8,000 × 0.10 | **800** |
| refund_amount | 0 | **0** |
| adjustment_amount | +5,000 + (-2,000) | **+3,000** |
| **payout_amount** | 100,000 - 0 - 8,000 - 800 + 3,000 | **94,200** |

### 기대 결과: SettlementItem

| Item ID | Type | Source ID | Amount | Description |
|---------|------|-----------|--------|-------------|
| SI-014 | SALE | ITEM-023 | 100,000 | - |
| SI-015 | ADJUSTMENT | ADJ-001 | +5,000 | 프로모션 보전금 |
| SI-016 | ADJUSTMENT | ADJ-002 | -2,000 | 수수료 정산 오류 정정 |

---

## 테스트 케이스 요약표

### 기능별 테스트 커버리지

| TC ID | 케이스명 | 검증 항목 | 우선순위 |
|-------|----------|-----------|----------|
| TC-S001 | 환불 없이 정상 판매만 | 기본 금액 계산 | 필수 |
| TC-S002 | 전체 환불 포함 | 환불 수수료 환급 | 필수 |
| TC-S003 | 부분 환불 포함 | 부분 환불 금액 계산 | 필수 |
| TC-S004 | 음수 정산 | 음수 payout 처리 | 필수 |
| TC-S005 | 경계 시간 | 기간 경계 처리 | 필수 |
| TC-S006 | 정산 제외 조건 | 제외 로직 | 필수 |
| TC-S007 | 중복 정산 방지 | 멱등성 | 필수 |
| TC-S008 | 조정 항목 포함 | Adjustment 처리 | 권장 |

### Seller별 종합 검증

| Seller | 시나리오 | Gross | Refund | Commission | Tax | Payout |
|--------|----------|-------|--------|------------|-----|--------|
| S001 | TC-S001 | 50,000 | 0 | 5,000 | 500 | 44,500 |
| S001 | TC-S002 | 120,000 | 50,000 | 7,000 | 700 | 62,300 |
| S001 | TC-S004 | 20,000 | 80,000 | 0 | 0 | -60,000 |
| S001 | TC-S006 | 60,000 | 0 | 6,000 | 600 | 53,400 |
| S001 | TC-S007 | 40,000 | 0 | 4,000 | 400 | 35,600 |
| S002 | TC-S001 | 100,000 | 0 | 8,000 | 800 | 91,200 |
| S002 | TC-S005 | 30,000 | 0 | 2,400 | 240 | 27,360 |
| S002 | TC-S008 | 100,000 | 0 | 8,000 | 800 | 94,200 |
| S003 | TC-S003 | 170,000 | 50,000 | 12,000 | 1,200 | 106,800 |

---

## JUnit 테스트 구조 예시

### 테스트 클래스 구조

```java
// src/test/java/com/example/settlement/SettlementCalculatorTest.java

@SpringBootTest
@Transactional
class SettlementCalculatorTest {

    @Autowired
    private SettlementCalculator settlementCalculator;

    @Autowired
    private TestDataFactory testDataFactory;

    private static final LocalDate TARGET_DATE = LocalDate.of(2025, 1, 15);
    private static final SettlementCycle CYCLE = SettlementCycle.DAILY;

    @Nested
    @DisplayName("TC-S001: 환불 없이 정상 판매만 있는 정산")
    class NormalSalesOnlyTest {

        @Test
        @DisplayName("Seller S001 - 기본 수수료율 10%")
        void shouldCalculateSettlementForSellerS001() {
            // Given
            Seller seller = testDataFactory.createSeller("S001", "판매자A", 0.10);
            testDataFactory.createPaidOrderItem(seller, 20_000, TARGET_DATE.atTime(10, 0));
            testDataFactory.createPaidOrderItem(seller, 30_000, TARGET_DATE.atTime(14, 30));

            // When
            Settlement settlement = settlementCalculator.calculate(
                seller.getId(), CYCLE, TARGET_DATE, TARGET_DATE
            );

            // Then
            assertThat(settlement.getGrossSalesAmount()).isEqualTo(new BigDecimal("50000"));
            assertThat(settlement.getCommissionAmount()).isEqualTo(new BigDecimal("5000"));
            assertThat(settlement.getTaxAmount()).isEqualTo(new BigDecimal("500"));
            assertThat(settlement.getRefundAmount()).isEqualTo(BigDecimal.ZERO);
            assertThat(settlement.getPayoutAmount()).isEqualTo(new BigDecimal("44500"));
        }

        @Test
        @DisplayName("Seller S002 - 프리미엄 수수료율 8%")
        void shouldCalculateSettlementForSellerS002() {
            // Given
            Seller seller = testDataFactory.createSeller("S002", "판매자B", 0.08);
            testDataFactory.createPaidOrderItem(seller, 45_000, TARGET_DATE.atTime(9, 0));
            testDataFactory.createPaidOrderItem(seller, 55_000, TARGET_DATE.atTime(18, 0));

            // When
            Settlement settlement = settlementCalculator.calculate(
                seller.getId(), CYCLE, TARGET_DATE, TARGET_DATE
            );

            // Then
            assertThat(settlement.getGrossSalesAmount()).isEqualTo(new BigDecimal("100000"));
            assertThat(settlement.getCommissionAmount()).isEqualTo(new BigDecimal("8000"));
            assertThat(settlement.getTaxAmount()).isEqualTo(new BigDecimal("800"));
            assertThat(settlement.getPayoutAmount()).isEqualTo(new BigDecimal("91200"));
        }
    }

    @Nested
    @DisplayName("TC-S002: 전체 환불이 포함된 정산")
    class FullRefundTest {

        @Test
        @DisplayName("전체 환불 시 수수료도 환급됨")
        void shouldDeductCommissionOnFullRefund() {
            // Given
            Seller seller = testDataFactory.createSeller("S001", "판매자A", 0.10);
            testDataFactory.createPaidOrderItem(seller, 40_000, TARGET_DATE.atTime(11, 0));
            OrderItem refundedItem = testDataFactory.createPaidOrderItem(
                seller, 50_000, TARGET_DATE.atTime(13, 0)
            );
            testDataFactory.createPaidOrderItem(seller, 30_000, TARGET_DATE.atTime(16, 0));

            testDataFactory.createFullRefund(refundedItem, TARGET_DATE.atTime(20, 0));

            // When
            Settlement settlement = settlementCalculator.calculate(
                seller.getId(), CYCLE, TARGET_DATE, TARGET_DATE
            );

            // Then
            assertThat(settlement.getGrossSalesAmount()).isEqualTo(new BigDecimal("120000"));
            assertThat(settlement.getRefundAmount()).isEqualTo(new BigDecimal("50000"));
            assertThat(settlement.getCommissionAmount()).isEqualTo(new BigDecimal("7000"));
            assertThat(settlement.getPayoutAmount()).isEqualTo(new BigDecimal("62300"));
        }
    }

    @Nested
    @DisplayName("TC-S004: 음수 정산")
    class NegativeSettlementTest {

        @Test
        @DisplayName("환불이 판매보다 많으면 음수 payout")
        void shouldAllowNegativePayoutAmount() {
            // Given
            Seller seller = testDataFactory.createSeller("S001", "판매자A", 0.10);
            testDataFactory.createPaidOrderItem(seller, 20_000, TARGET_DATE.atTime(10, 0));

            // 이전 기간 판매에 대한 환불
            testDataFactory.createRefundForPreviousSale(seller, 50_000, TARGET_DATE.atTime(14, 0));
            testDataFactory.createRefundForPreviousSale(seller, 30_000, TARGET_DATE.atTime(16, 0));

            // When
            Settlement settlement = settlementCalculator.calculate(
                seller.getId(), CYCLE, TARGET_DATE, TARGET_DATE
            );

            // Then
            assertThat(settlement.getGrossSalesAmount()).isEqualTo(new BigDecimal("20000"));
            assertThat(settlement.getRefundAmount()).isEqualTo(new BigDecimal("80000"));
            assertThat(settlement.getPayoutAmount()).isEqualTo(new BigDecimal("-60000"));
            assertThat(settlement.isNegative()).isTrue();
        }
    }

    @Nested
    @DisplayName("TC-S005: 경계 시간대 처리")
    class BoundaryTimeTest {

        @Test
        @DisplayName("정산 기간 시작(00:00:00) - 포함")
        void shouldIncludeOrderAtMidnight() {
            // Given
            Seller seller = testDataFactory.createSeller("S002", "판매자B", 0.08);
            testDataFactory.createPaidOrderItem(seller, 10_000,
                TARGET_DATE.atTime(0, 0, 0, 0));

            // When
            Settlement settlement = settlementCalculator.calculate(
                seller.getId(), CYCLE, TARGET_DATE, TARGET_DATE
            );

            // Then
            assertThat(settlement.getGrossSalesAmount()).isEqualTo(new BigDecimal("10000"));
        }

        @Test
        @DisplayName("정산 기간 종료(23:59:59.999) - 포함")
        void shouldIncludeOrderAtEndOfDay() {
            // Given
            Seller seller = testDataFactory.createSeller("S002", "판매자B", 0.08);
            testDataFactory.createPaidOrderItem(seller, 20_000,
                TARGET_DATE.atTime(23, 59, 59, 999_999_999));

            // When
            Settlement settlement = settlementCalculator.calculate(
                seller.getId(), CYCLE, TARGET_DATE, TARGET_DATE
            );

            // Then
            assertThat(settlement.getGrossSalesAmount()).isEqualTo(new BigDecimal("20000"));
        }

        @Test
        @DisplayName("전일 23:59:59.999 - 제외")
        void shouldExcludeOrderFromPreviousDay() {
            // Given
            Seller seller = testDataFactory.createSeller("S002", "판매자B", 0.08);
            testDataFactory.createPaidOrderItem(seller, 30_000,
                TARGET_DATE.minusDays(1).atTime(23, 59, 59, 999_999_999));

            // When
            Settlement settlement = settlementCalculator.calculate(
                seller.getId(), CYCLE, TARGET_DATE, TARGET_DATE
            );

            // Then
            assertThat(settlement.getGrossSalesAmount()).isEqualTo(BigDecimal.ZERO);
        }
    }

    @Nested
    @DisplayName("TC-S007: 중복 정산 방지")
    class DuplicatePreventionTest {

        @Test
        @DisplayName("이미 정산된 OrderItem은 제외")
        void shouldExcludeAlreadySettledItems() {
            // Given
            Seller seller = testDataFactory.createSeller("S001", "판매자A", 0.10);

            OrderItem alreadySettled = testDataFactory.createPaidOrderItem(
                seller, 30_000, TARGET_DATE.atTime(10, 0)
            );
            testDataFactory.markAsSettled(alreadySettled, SettlementStatus.CONFIRMED);

            testDataFactory.createPaidOrderItem(seller, 40_000, TARGET_DATE.atTime(11, 0));

            // When
            Settlement settlement = settlementCalculator.calculate(
                seller.getId(), CYCLE, TARGET_DATE, TARGET_DATE
            );

            // Then
            assertThat(settlement.getGrossSalesAmount()).isEqualTo(new BigDecimal("40000"));
            assertThat(settlement.getItems()).hasSize(1);
        }
    }
}
```

### TestDataFactory 예시

```java
// src/test/java/com/example/settlement/support/TestDataFactory.java

@Component
public class TestDataFactory {

    @Autowired private SellerRepository sellerRepository;
    @Autowired private OrderRepository orderRepository;
    @Autowired private OrderItemRepository orderItemRepository;
    @Autowired private PaymentRepository paymentRepository;
    @Autowired private RefundRepository refundRepository;
    @Autowired private SettlementRepository settlementRepository;
    @Autowired private SettlementItemRepository settlementItemRepository;

    public Seller createSeller(String code, String name, double commissionRate) {
        Seller seller = Seller.builder()
            .sellerCode(code)
            .sellerName(name)
            .commissionRate(BigDecimal.valueOf(commissionRate))
            .status(SellerStatus.ACTIVE)
            .settlementCycle(SettlementCycle.DAILY)
            .build();
        return sellerRepository.save(seller);
    }

    public OrderItem createPaidOrderItem(Seller seller, int amount, LocalDateTime paidAt) {
        Order order = Order.builder()
            .orderNumber(generateOrderNumber())
            .seller(seller)
            .status(OrderStatus.PAID)
            .totalAmount(BigDecimal.valueOf(amount))
            .orderedAt(paidAt)
            .build();
        order = orderRepository.save(order);

        OrderItem item = OrderItem.builder()
            .order(order)
            .productName("테스트 상품")
            .quantity(1)
            .unitPrice(BigDecimal.valueOf(amount))
            .totalPrice(BigDecimal.valueOf(amount))
            .status(OrderItemStatus.ACTIVE)
            .build();
        item = orderItemRepository.save(item);

        Payment payment = Payment.builder()
            .paymentKey(generatePaymentKey())
            .order(order)
            .amount(BigDecimal.valueOf(amount))
            .status(PaymentStatus.CONFIRMED)
            .paidAt(paidAt)
            .build();
        paymentRepository.save(payment);

        return item;
    }

    public Refund createFullRefund(OrderItem item, LocalDateTime refundedAt) {
        Refund refund = Refund.builder()
            .refundKey(generateRefundKey())
            .orderItem(item)
            .refundType(RefundType.FULL)
            .refundAmount(item.getTotalPrice())
            .status(RefundStatus.COMPLETED)
            .refundedAt(refundedAt)
            .build();
        return refundRepository.save(refund);
    }

    public void markAsSettled(OrderItem item, SettlementStatus status) {
        Settlement settlement = Settlement.builder()
            .seller(item.getOrder().getSeller())
            .cycleType(SettlementCycle.DAILY)
            .periodStart(item.getOrder().getOrderedAt().toLocalDate())
            .periodEnd(item.getOrder().getOrderedAt().toLocalDate())
            .status(status)
            .grossSalesAmount(item.getTotalPrice())
            .build();
        settlement = settlementRepository.save(settlement);

        SettlementItem settlementItem = SettlementItem.builder()
            .settlement(settlement)
            .itemType(SettlementItemType.SALE)
            .sourceType("ORDER_ITEM")
            .sourceId(item.getId())
            .grossAmount(item.getTotalPrice())
            .build();
        settlementItemRepository.save(settlementItem);
    }

    // ... 기타 헬퍼 메서드
}
```

---

## 관련 문서

- [[도메인 정의서]]
- [[정산 규칙 및 정책]]
- [[ERD 및 테이블 설계]]
- [[유스케이스 명세서]]
- [[사이드 프로젝트 공통 가이드]]
